<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />
  <style>
    body  {
      margin: 0;
    }
    thumbstick-input, button-cluster-input {
      display: block;
      width: 4cm;
    }
    @media (pointer: coarse) {
      thumbstick-input, button-cluster-input {
        width: 8cm;
      }
    }
    gamepad-display {
      display: block;
      width: 12cm;
    }
    gamepad-input {
      height: 100%;
      max-height: 100%;
      max-width: 100%;
    }
    url-qr-code {
      position: absolute;
      inset: 0;
    }
  </style>
</head>
<body style="background: lightblue;">
  <!--
  <gamepad-display></gamepad-display>
  <gamepad-display></gamepad-display>
  <gamepad-input overlap></gamepad-input>
   <div style="font-size: 10vh">
    x: <span class="x"></span><br/>
    y: <span class="y"></span><br/>
    z: <span class="z"></span><br/>
    a: <span class="a"></span><br/>
    b: <span class="b"></span><br/>
    g: <span class="g"></span><br/>
    abs: <span class="abs"></span><br/>
  </div>
  <gamepad-display></gamepad-display>
  <gamepad-display></gamepad-display>
  <div style="font-size: 10vh">
    a: <span class="a"></span><br/>
    b: <span class="b"></span><br/>
    x: <span class="x"></span><br/>
    y: <span class="y"></span><br/>
  </div>
  <div id="extras" style="font-size: 2vw; font-family: sans">
  -->
  </div>

  <script src="https://unpkg.com/qrcode@1.5.1/build/qrcode.js"></script>
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.js"></script>
  <script type="module">
    import { Gamepads } from './get_gamepads.js';
    import './gamepad.js';
    import './gamepad_display.js';
    import './qr.js';
    const letters = 'BCDFGHJKLMNPQRSTVWXZ';
    const getLetter = () => letters.charAt(Math.floor(Math.random() * letters.length));
    const loc = document.location;
    const params = new URLSearchParams(loc.hash.substr(1));

    let roomCode = params.get('rc');
    const isClient = roomCode != null;
    if (isClient) {
      const pad = document.createElement('gamepad-input');
      document.body.appendChild(pad);
    } else {
      roomCode = Array.from({ length: 4 }, getLetter).join('');
      const clientUrl = new URL(loc);
      clientUrl.hash = '?rc=' + roomCode;
      const qr = document.createElement('url-qr-code');
      qr.href = clientUrl.toString();
      document.body.appendChild(qr);

      const style = document.createElement('style');
      style.textContent = `
      gamepad-input {
        position: absolute;
        inset: 0;
        transform: translate(calc(var(--x, 0) * 1px), calc(var(--y, 0) * 1px));
        height: 10vmin;
        width: 10vmin;
        border-radius: 50%;
      }`;
      document.head.appendChild(style);

      window.addEventListener('gamepadconnected', (e) => {
        const padDisplay = document.createElement('gamepad-input');
        padDisplay.overlap = '';
        padDisplay.style.background = `hsl(${Math.random()}turn,100%,65%)`;
        padDisplay.value = e.gamepad;
        document.body.appendChild(padDisplay);

        const disconnect = ({gamepad}) => {
          if (padDisplay.value.index !== gamepad.index) return;
          padDisplay.remove();
          padDisplay.value = gamepad;
          window.removeEventListener('gamepaddisconnected', disconnect);
        };
        window.addEventListener('gamepaddisconnected', disconnect);

        let lastUpdate = Date.now();
        let x = 0;
        let y = 0;
        let lastPadTimestamp = Date.now();
        const updateDisplay = () => {
          if (!padDisplay.value.connected) return;
          const gamepad = navigator.getGamepads()[padDisplay.value.index];
          if (!gamepad?.connected) return;
          const timestamp = gamepad?.timestamp;
          if (timestamp != lastPadTimestamp) {
            padDisplay.value = gamepad;
            lastPadTimestamp = timestamp;
          }
          const currentTime = Date.now();
          const deltaTime = currentTime - lastUpdate;

          const deadZone = (axis) =>
            Math.sign(axis) * Math.max(Math.abs(axis) - .1, 0) / .9;
          let xAxis = deadZone(gamepad.axes[0]);
          let yAxis = deadZone(gamepad.axes[1]);
          if (xAxis**2 + yAxis**2 > 1) {
            let theta = Math.atan(yAxis / xAxis);
            let sign = Math.sign(xAxis);
            xAxis = sign * Math.cos(theta);
            yAxis = sign * Math.sin(theta);
          }

          x += xAxis * deltaTime;
          y += yAxis * deltaTime;
          const maxX = window.innerWidth - padDisplay.offsetWidth;
          const maxY = window.innerHeight - padDisplay.offsetHeight;
          x = (x < 0) ? 0 : (x > maxX) ? maxX : x;
          y = (y < 0) ? 0 : (y > maxY) ? maxY : y;
          padDisplay.style.setProperty('--x', x);
          padDisplay.style.setProperty('--y', y);
          lastUpdate = currentTime;
          requestAnimationFrame(updateDisplay);
        }
        updateDisplay();
      });
    }

    const peerId = [...new Uint8Array(await crypto.subtle.digest("SHA-1", new TextEncoder("utf-8").encode(roomCode)))]
      .map(x => x.toString(16).padStart(2, '0'))
      .join('');
    console.log({ isClient, roomCode, peerId });

    if (isClient) {
      const peer = new Peer();
      peer.on('error', console.log);
      peer.on('open', (id) => {
        const conn = peer.connect(peerId);
        window.peer = peer;
        conn.on('error', console.log);
        conn.on('open', () => {
          conn.on('data', (data) => {
            if (data?.type != 'background') return;
            document.body.style.background = data.background;
          });
          const sentGamepads = [];
          const target = new EventTarget();

          const sendData = (force) => {
            const gamepads = navigator.getGamepads();
            let sendGamepads = force;
            for (const gamepad of gamepads) {
              const i = gamepad.index;
              sentGamepads[i] ??= {};
              const sentGamepad = sentGamepads[i];
              if (sentGamepad.timestamp >= gamepad.timestamp) continue;
              sendGamepads = true;
              for (const prop of ['axes', 'connected', 'id', 'index', 'mapping', 'timestamp']) {
                const val = gamepad[prop];
                if (val !== undefined) sentGamepad[prop] = val;
              }
              if (gamepad.buttons) {
                sentGamepad.buttons = gamepad.buttons.map(
                  ({pressed, touched, value}) => ({pressed, touched, value})
                );
              }
            }
            if (sendGamepads) {
              conn.send({type: 'gamepads', timestamp: Date.now(), gamepads: sentGamepads});
            }
          }

          document.querySelectorAll('gamepad-input').forEach((el, index) => {
            el.addEventListener('input', () => sendData());
          });

          const sendDataOnAnimationFrame = () => {
            sendData(true);
            requestAnimationFrame(sendDataOnAnimationFrame);
          }
          sendData();
        });
      });
    } else {
      const peer = new Peer(peerId);//, {debug: 3});
      window.peer = peer;
      peer.on('error', console.log);
      peer.on('connection', (conn) => {
        conn.on('error', console.log);
        conn.on('open', () => {
          let heldGamepads = [];
          let heldTimestamp = 0;
          const target = new EventTarget();
          Gamepads.register(target, () => heldGamepads);

          conn.on('data', (data) => {
            if (data?.type != 'gamepads' || data.timestamp <= heldTimestamp) return;
            const oldGamepads = heldGamepads;
            heldTimestamp = data.timestamp;
            heldGamepads = data.gamepads;
            for (const gamepad of heldGamepads) {
              const { index, connected } = gamepad;
              const oldGamepad = oldGamepads[index];
              if (oldGamepad?.connected === connected) continue;
              const eventName = (connected) ? 'gamepadconnected' : 'gamepaddisconnected';
              const event = new Event(eventName);
              event.gamepad = gamepad;
              target.dispatchEvent(event);
            }
          });
          conn.on('close', () => {
            console.log('connection close');
            for (const gamepad of heldGamepads) {
              gamepad.connected = false;
            }
            for (const gamepad of heldGamepads) {
              const event = new Event('gamepaddisconnected');
              event.gamepad = gamepad;
              target.dispatchEvent(event);
            }
          });
          conn.peerConnection.addEventListener("connectionstatechange", (event) => {
            if (conn.peerConnection.connectionState === 'disconnected') {
              conn.close();
            }
          });
        });
      });
    }

    {
      const gamepadInputs = document.querySelectorAll('gamepad-input');
      const target = new EventTarget();

      gamepadInputs.forEach((el, index) => {
        el.value = { index };

        const sendConnected = (e) => {
          if (!e.target.value.connected) return;

          el.removeEventListener('input', sendConnected);
          const event = new Event('gamepadconnected');
          event.gamepad = e.target.value;
          target.dispatchEvent(event);
        };

        el.addEventListener('input', sendConnected);
      });

      Gamepads.register(target, () => Array.from(gamepadInputs, el => el.value));
    }

    // // connect first web gamepad to second.
    // const gamepadInputs = document.querySelectorAll('gamepad-input');
    // gamepadInputs[0]?.addEventListener('input', (e) => {
    //   if (gamepadInputs[1]) {
    //     const { index } = gamepadInputs[1].value;
    //     gamepadInputs[1].value = {...e.target.value, index};
    //   }
    // });

    {
      const displays = Array.from(document.querySelectorAll('gamepad-display'));
      const $extras = document.querySelector('#extras');
      displays.forEach((display, i) => {
        let lastTimestamp = 0;
        const updateDisplay = () => {
          const gamepad = navigator.getGamepads()[i];
          const timestamp = gamepad?.timestamp;
          if (timestamp != lastTimestamp) {
            const extras = display.updateState(gamepad) || [];
            // $extras.innerHTML = extras.map(e => e.join(': ')).join('<br/>');
            lastTimestamp = timestamp;
          }
          requestAnimationFrame(updateDisplay);
        }
        updateDisplay();
      });
    }
 
    // Doesn't work unless HTTPS, (*\.)?localhost, 127.0.0.1, or file:// urls
    // 0.0.0.0 does *not* work.
    if (false) {
      const none = { textContent: "" };
      const accelX = document.querySelector('.x') ?? none;
      const accelY = document.querySelector('.y') ?? none;
      const accelZ = document.querySelector('.z') ?? none;
      const a = document.querySelector('.a') ?? none;
      const b = document.querySelector('.b') ?? none;
      const g = document.querySelector('.g') ?? none;
      const abs = document.querySelector('.abs') ?? none;
      let x = 0;
      let y = 0;
      let z = 0;
      let alpha = 0;
      let beta = 0;
      let gamma = 0;
      let absolute = false;
      // window.addEventListener('devicemotion', (e) => {
      //   ({x, y, z} = e.acceleration);
      //   ({alpha, beta, gamma} = e.rotationRate);
      // }, true);
      window.addEventListener('deviceorientation', (e) => {
        ({alpha, beta, gamma, absolute} = e);
      }, true);
      const updateDisplay = () => {
        accelX.textContent = x?.toFixed(3);
        accelY.textContent = y?.toFixed(3);
        accelZ.textContent = z?.toFixed(3);
        a.textContent = alpha?.toFixed(3);
        b.textContent = beta?.toFixed(3);
        g.textContent = gamma?.toFixed(3);
        abs.textContent = absolute;
        requestAnimationFrame(updateDisplay);
      };
      updateDisplay();
    }

    {
      // stop device from sleeping
      let wakeLock = null;
      const requestWakeLock = async () => {
        if (wakeLock !== null || document.visibilityState !== 'visible') {
          return;
        }
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => wakeLock = null);
        } catch (err) {
          console.log(err);
        }
      }
      document.addEventListener('visibilitychange', requestWakeLock);
      requestWakeLock();
    }
    
    // for full gamepad:
    // if navigator.maxTouchPoints <= 1,
    // alert user that they won't have a great experience
    // detect portrait vs landscape prompt user to rotate device
    // offer to go fullscreen
    // request no sleep
    // input.meta.url query params to configure

    // Need better support for pressing two buttons at once with one thumb.
    // Right now it only checks the midpoint.
    // The width/height that pointer events gives us might not be good enough.

    // // for mapping to onscreen controls:
    // // from https://stackoverflow.com/a/36144688
    // function click(x, y) {
    //   document.elementFromPoint(x, y).dispatchEvent(
    //     new MouseEvent('click', {
    //       view: window,
    //       bubbles: true,
    //       cancelable: true,
    //       screenX: x,
    //       screenY: y
    //     })
    //   );
    // }

    // wire format:
    // TODO(geophree): figure out connected/id/index/mapping
    // - index implied?
    // array of doubles
    // - version
    // - ??? total length?
    // - number of gamepads
    // - number of included gamepads (until last non-zero)
    // - ??? list of indexes for each included gamepad?
    // - is a gamepad:
    //   - length of gamepad (zero means disconnected?)
    //   - timestamp
    //   - axes:
    //     - number of axes
    //     - number of included axes (until last non-zero)
    //     - list of axes (doubles) (range: -1.0 - 1.0)
    //   - is buttons:
    //     - number of buttons
    //     - number of included buttons (until last non-zero)
    //     - list of buttons:
    //       - double with two boolean bits (& 2 and & 4) (pressed/touched)
    //       - the double itself is pressure (range: 0.0 - 1.0) (val %= 2)

    // TODO(geophree):
    // - thumbstick: octagon limiter (gamecube style)
    //   - small size, goes out of its bounds
    //     - easier to put two with d-pad and face buttons on phone
  </script>
</body>
</html>
