<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />
  <style>
    thumbstick-input, button-cluster-input {
      display: block;
      width: 4cm;
    }
    @media (pointer: coarse) {
      thumbstick-input, button-cluster-input {
        width: 8cm;
      }
    }
    gamepad-display {
      display: block;
      width: 12cm;
    }
  </style>
</head>
<body style="background: lightblue;">
  <div style="font-size: 10vh">
    x: <span class="x"></span><br/>
    y: <span class="y"></span><br/>
    z: <span class="z"></span><br/>
    a: <span class="a"></span><br/>
    b: <span class="b"></span><br/>
    g: <span class="g"></span><br/>
    abs: <span class="abs"></span><br/>
  </div>
  <!--
  <gamepad-display></gamepad-display>
  <gamepad-display></gamepad-display>
  <gamepad-display></gamepad-display>
  <gamepad-display></gamepad-display>
  <div style="font-size: 10vh">
    a: <span class="a"></span><br/>
    b: <span class="b"></span><br/>
    x: <span class="x"></span><br/>
    y: <span class="y"></span><br/>
  </div>
  <thumbstick-input id="thumb1"></thumbstick-input>
  <button-cluster-input></button-cluster-input>
  <div id="extras" style="font-size: 2vw; font-family: sans">
  -->
  </div>

  <script type="module">
    import './get_gamepads.js';
    import './thumbstick.js';
    import './button_cluster.js';
    import './gamepad_display.js';
    const virtual_gamepad = {};

    {
      const gamepad = virtual_gamepad;
      const displays = Array.from(document.querySelectorAll('gamepad-display'));
      const $extras = document.querySelector('#extras');
      displays.forEach((display, i) => {
        let lastTimestamp = 0;
        const updateDisplay = () => {
          const gamepad = navigator.getGamepads()[i];
          const timestamp = gamepad?.timestamp;
          if (timestamp != lastTimestamp) {
            const extras = display.updateState(gamepad) || [];
            // $extras.innerHTML = extras.map(e => e.join(': ')).join('<br/>');
            lastTimestamp = timestamp;
          }
          requestAnimationFrame(updateDisplay);
        }
        updateDisplay();
      });
    }
 
    // // value getter for axes, dispatch InputEvent when it changes
    // const a = document.querySelector('.a');
    // const b = document.querySelector('.b');
    // const x = document.querySelector('.x');
    // const y = document.querySelector('.y');
    {
      const gamepad = virtual_gamepad;
      const input = document.querySelector('button-cluster-input');
      if (input) {
        const updateDisplay = () => {
          gamepad.buttons = input.value.map((value) => ({
            pressed: value > .1,
            touched: value > 0,
            value
          }));
          gamepad.connected = true;
          gamepad.timestamp = performance.now();
        };

        input.addEventListener('input', updateDisplay);
        updateDisplay();
      }
    }


    // // value getter for axes, dispatch InputEvent when it changes
    // const x = document.querySelector('.x');
    // const y = document.querySelector('.y');
    {
      const gamepad = virtual_gamepad;
      const input = document.querySelector('thumbstick-input');
      if (input) {
        const updateDisplay = () => {
          gamepad.axes = input.value;
          gamepad.connected = true;
          gamepad.timestamp = performance.now();
        };

        input.addEventListener('input', updateDisplay);
        updateDisplay();
      }
    }

    // Doesn't work unless HTTPS, (*\.)?localhost, 127.0.0.1, or file:// urls
    // 0.0.0.0 does *not* work.
    {
      const accelX = document.querySelector('.x');
      const accelY = document.querySelector('.y');
      const accelZ = document.querySelector('.z');
      const a = document.querySelector('.a');
      const b = document.querySelector('.b');
      const g = document.querySelector('.g');
      const abs = document.querySelector('.abs');
      let x = 0;
      let y = 0;
      let z = 0;
      let alpha = 0;
      let beta = 0;
      let gamma = 0;
      let absolute = false;
      // window.addEventListener('devicemotion', (e) => {
      //   ({x, y, z} = e.acceleration);
      //   ({alpha, beta, gamma} = e.rotationRate);
      // }, true);
      window.addEventListener('deviceorientation', (e) => {
        ({alpha, beta, gamma, absolute} = e);
      }, true);
      const updateDisplay = () => {
        accelX.textContent = x?.toFixed(3);
        accelY.textContent = y?.toFixed(3);
        accelZ.textContent = z?.toFixed(3);
        a.textContent = alpha?.toFixed(3);
        b.textContent = beta?.toFixed(3);
        g.textContent = gamma?.toFixed(3);
        abs.textContent = absolute;
        requestAnimationFrame(updateDisplay);
      };
      updateDisplay();
    }

    {
      // stop device from sleeping
      let wakeLock = null;
      const requestWakeLock = async () => {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', console.log);
        } catch (err) {
          console.log(err);
        }
      }

      const handleVisibilityChange = () => {
        if (wakeLock !== null && document.visibilityState === 'visible') {
          requestWakeLock();
        }
      }
      document.addEventListener('visibilitychange', handleVisibilityChange);

      requestWakeLock();
    }
    
    // for full gamepad:
    // if navigator.maxTouchPoints <= 1,
    // alert user that they won't have a great experience
    // detect portrait vs landscape prompt user to rotate device
    // offer to go fullscreen
    // request no sleep
    // input.meta.url query params to configure

    // Need better support for pressing two buttons at once with one thumb.
    // Right now it only checks the midpoint.
    // The width/height that pointer events gives us might not be good enough.

    // // for mapping to onscreen controls:
    // // from https://stackoverflow.com/a/36144688
    // function click(x, y) {
    //   document.elementFromPoint(x, y).dispatchEvent(
    //     new MouseEvent('click', {
    //       view: window,
    //       bubbles: true,
    //       cancelable: true,
    //       screenX: x,
    //       screenY: y
    //     })
    //   );
    // }

    // wire format:
    // TODO(geophree): figure out connected/id/index/mapping
    // - index implied?
    // array of doubles
    // - version
    // - ??? total length?
    // - number of gamepads
    // - number of included gamepads (until last non-zero)
    // - ??? list of indexes for each included gamepad?
    // - is a gamepad:
    //   - length of gamepad (zero means disconnected?)
    //   - timestamp
    //   - axes:
    //     - number of axes
    //     - number of included axes (until last non-zero)
    //     - list of axes (doubles) (range: -1.0 - 1.0)
    //   - is buttons:
    //     - number of buttons
    //     - number of included buttons (until last non-zero)
    //     - list of buttons:
    //       - double with two boolean bits (& 2 and & 4) (pressed/touched)
    //       - the double itself is pressure (range: 0.0 - 1.0) (val %= 2)

    // TODO(geophree):
    // - thumbstick: octagon limiter (gamecube style)
    //   - small size, goes out of its bounds
    //     - easier to put two with d-pad and face buttons on phone
  </script>
</body>
</html>
